<head>
    <style>
        body {
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" height="700" width="1000"></canvas>
</body>
<script>
    // constants
    const PI = Math.PI,
        sqrt = Math.sqrt,
        sin = Math.sin,
        cos = Math.cos,
        atan2 = Math.atan2,
        abs = Math.abs,
        min = Math.min,
        max = Math.max,
        random = Math.random,
        floor = Math.floor;
    const toRad = x => x * PI / 180,
        toDeg = x => x * 180 / PI;

    // utils
    const randomItem = arr => arr[floor((random() * arr.length))];

    // physics engine
    class Point {
        constructor(x, y) {
            if (typeof x != "number" || typeof y != "number")
                throw TypeError('Point constructor must be a number');
            this.x = x;
            this.y = y;
        }
        isEqual(p1) {
            return (p1.x == p2.x) && (p1.y == p2.y)
        }
        copy() {
            // copy to return new point without reference
            return new Point(this.x, this.y);
        }
    }

    class Vector {
        #dir = 0;
        get dir() {
            return this.#dir;
        }
        set dir(x) {
            if (x < 0) x = 360 * 10 - abs(x) ; // dumb patch work
            this.#dir = x % 360;
        }
        constructor(length, direction) {
            if (typeof length != "number" || typeof direction != "number")
                throw TypeError('Vector constructor must be a number');
            this.len = length;
            this.dir = direction;
        }
        toPoints() {
            // convert to the next relative points
            // cos theta = (x/l)
            let dir = this.dir, len = this.len;
            return new Point(
                cos(toRad(dir)) * len,
                sin(toRad(dir)) * len
            )
        }
        static fromPoints(p1, p2) {
            // generate vector from points
            let x = p2.x - p1.x, y = p2.y - p1.y;
            return new Vector(
                sqrt(x*x + y*y),
                toDeg(atan2(y, x))
            );
        }
    }
    // rocket properties
    const rockProp = [
        {
            maxSpeed: 100, // pixels per tick
            turnDeg: 7, // turn degree per tick
            fuel: 10000, // how many pixels before out of fuel
            exRad: 150, // explosion radius
            start: [
                new Point(3500, 3500),
                new Point(1000, 1000),
            ],
            system: () => {
                let enemyRock = Rocket.list.filter(r => r.team === 1);
                Rocket.list
                    .filter(r => r.team === 0)
                    .forEach(rocket => {
                        rocket.tar = randomItem(enemyRock).pos.copy();
                    });
            }
        },
        {
            maxSpeed: 100,
            turnDeg: 5, 
            fuel: 50000,
            exRad: 500,
            start: [
                new Point(7000, 7000)
            ],
            system: () => {
                Rocket.list
                    .filter(r => r.team === 1)
                    .forEach(rocket => {
                        rocket.tar = randomItem(rockProp[0].start)
                    })
            }
        }
    ]

    class Rocket {
        static list = [];
        constructor(vector, team) {
            // which team own this rocket
            if (!((vector instanceof Vector) && (typeof team == 'number')))
                throw TypeError('Rocket constructor types invalid');

            this.vec = vector; this.tar; this.team = team;
            for (const property in rockProp[team]) {
                if (property == 'start' || property == 'system') continue;
                // copy properties
                const value = rockProp[team][property];
                this[property] = value;
            }

            // chose random start position
            this.pos = randomItem(rockProp[team].start).copy();
            
            Rocket.list.push(this);
        }
        getNextPoint() {
            // get the next point with absolute coord
            let x = this.pos.x, y = this.pos.y,
                rel = this.vec.toPoints();
            return new Point(x + rel.x, y + rel.y)
        }
        tickMove() {
            this.pos = this.getNextPoint(); // go to next point
            this.fuel -= this.vec.len; // reduce fuel

            // is in the explosion range, using Vector.fromPoint() to calculate the distance
            let dis = Vector.fromPoints(this.pos, this.tar);
            if (dis.len <= this.exRad || this.fuel <= 0)
                return this.destroy(this);

            // calculate next route using commander of each team (aka turn to the target)             
            let tarVec = Vector.fromPoints(this.pos, this.tar); // use vector to get expected route
            let d = tarVec.dir - this.vec.dir; // difference between expected place
            if (abs(d) > 180) {
                d = (this.vec.dir - tarVec.dir)
            }
            // check expected turn
            this.vec.dir += (d < 0)? max(d, -this.turnDeg) : min(d, this.turnDeg); 
            this.vec.len = min(tarVec.len, this.maxSpeed);
        }
        destroy() {            
            this.destroyed = true;

            for (const rocket of Rocket.list) {
                if (rocket.destroyed == true) continue; // the rocket was triggered
                let dis = Vector.fromPoints(this.pos, rocket.pos);
                if (this.exRad < dis.len) continue; // out of explosion radius
                rocket.destroy(rocket);
            }
        }
    }
</script>
<script>
    // display
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.scale(0.1, 0.1)

    let currentStrokeType = ''; // current stroke to optimize

    const can = {
        setStroke: type => {
            // https://coolors.co/a63446-fbfef9-0c6291-fa824c-157f1f
            if (type === currentStrokeType) return; // no need to set again
            if (type == 'r') {
                // rocket
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#fbfef9'
            } else if (type === 0) {
                // projected team 0
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#0C6291'
            } else if (type === 1) {
                // projected team 1
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#A63446'
            } else if (type == 'e') {
                // explosion
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#FA824C'
            }
        },
        line: (p1, p2, type) => {
            can.setStroke(type)
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        },
        circle: (cen, rad) => {
            // draw a circle with center as a point
            can.setStroke('e');
            ctx.beginPath();
            ctx.arc(cen.x, cen.y, rad, 0, 2 * PI);
            ctx.stroke();
        },
        tick: () => {
            ctx.rect(0, 0, 10000, 10000);
            ctx.fill();

            rockProp[0].system();
            rockProp[1].system()

            for (let l1 = 0; l1 < Rocket.list.length; l1++) {
                let rocket = Rocket.list[l1];
                let p0 = rocket.pos.copy();
                rocket.tickMove();
                let p2 = rocket.getNextPoint();

                can.line(rocket.pos, p0, 'e'); // trail
                can.line(rocket.pos, p2, 'r');
                can.line(rocket.pos, rocket.tar, rocket.team);

                if (rocket.destroyed == true) {
                    can.circle(rocket.pos, rocket.exRad); // draw
                    Rocket.list.splice(l1, 1);
                    l1--;
                }
            };
        }
    }

    // debug
    new Rocket(new Vector(1000, 0), 0);
    new Rocket(new Vector(1000, 90), 0);

    new Rocket(new Vector(1000, 270), 1);
    new Rocket(new Vector(1000, 179), 1);

    let sim = setInterval(() => {
        can.tick();
        if (Rocket.list.length <= 1) clearInterval(sim);
    }, 100);
    // setInterval(() => {
    //     new Rocket(new Vector(1000, 90), new Point(0, 0), 0)
    // }, 1000);
    can.tick()
</script>