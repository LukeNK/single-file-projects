<head>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            font-size: xx-large;
            background-color: black;
            color: #fbfef9;
        }

        #stats {
            position: fixed;
            width: 100%; /* Full width (cover the whole page) */
            height: 100%; /* Full height (cover the whole page) */
            top: 1rem;
            left: 1rem;
            right: 0;
            bottom: 0;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div id="stats">
        <p>Team 0: <span id="team0"></span></p>
        <p>Team 1: <span id="team1"></span></p>
        <p>Missiles: <span id="objects"></span></p>
    </div>
    <canvas id="canvas" height="5000" width="5000"></canvas>
</body>
<script>
    const Delta = 0.1; // Length between frames
    // constants
    const PI = Math.PI,
        sqrt = Math.sqrt,
        sin = Math.sin,
        cos = Math.cos,
        atan2 = Math.atan2,
        abs = Math.abs,
        min = Math.min,
        max = Math.max,
        random = Math.random,
        floor = Math.floor;
    const toRad = x => x * PI / 180,
        toDeg = x => x * 180 / PI;

    // utils
    const randomItem = arr => arr[floor((random() * arr.length))];

    // physics engine
    class Point {
        constructor(x, y) {
            if (typeof x != "number" || typeof y != "number")
                throw TypeError('Point constructor must be a number');
            this.x = x;
            this.y = y;
        }
        copy() {
            // copy to return new point without reference
            return new Point(this.x, this.y);
        }
    }

    class Vector {
        #dir = 0;
        get dir() {
            return this.#dir;
        }
        set dir(x) {
            if (x < 0) x = 360 * 10 - abs(x) ; // dumb patch work
            this.#dir = x % 360;
        }
        constructor(length, direction) {
            if (typeof length != "number" || typeof direction != "number")
                throw TypeError('Vector constructor must be a number');
            this.len = length;
            this.dir = direction;
        }
        toPoint() {
            // convert to the next relative points
            // cos theta = (x/l)
            let dir = this.dir, len = this.len;
            return new Point(
                cos(toRad(dir)) * len,
                sin(toRad(dir)) * len
            )
        }
        static fromPoints(p1, p2) {
            // generate vector from points
            let x = p2.x - p1.x, y = p2.y - p1.y;
            return new Vector(
                sqrt(x*x + y*y),
                toDeg(atan2(y, x))
            );
        }
        copy() {
            return new Vector(this.len, this.dir)
        }
        dirDiff(v2) {
            // difference dir between two vectors
            let d = this.dir - v2.dir; // difference between expected place
            if (abs(d) > 180)
                d = v2.dir - this.dir
            return d;
        }
    }

    class Plane {
        static airports = [
            [
                // team 0 airports
                {pos: new Point(0, 1300), dir: 0},
                {pos: new Point(50, 1400), dir: 0},
                {pos: new Point(100, 1500), dir: 0},
                {pos: new Point(50, 1600), dir: 0},
                {pos: new Point(0, 1700), dir: 0},
            ],
            [
                // team 1 airports
                {pos: new Point(5000, 1300), dir: 180},
                {pos: new Point(5000, 1400), dir: 180},
                {pos: new Point(5000, 1500), dir: 180},
                {pos: new Point(5000, 1600), dir: 180},
                {pos: new Point(5000, 1700), dir: 180},
            ]
        ]
        static models = [
            {
                name: "Uria 3 â€” Seeker: UAV", // just a name
                maxSpeed: 175, // m/s
                acceleration: 1, // m/s^2
                v1: 55, // minimum speed, plane can start to turn after this
                turnDeg: 28, // turn degree per second
                missile: 0, // missile model
                missileGroup: 2, // how many missile in a group before cooling down
                missileRate: 3 / Delta, // second per missile (frames per missile)
                flare: 1,
                flareGroup: 7,
                flareRate: 7 / Delta,
            }
        ]
        static list = []
        constructor(vector, team, model, start) {
            this.vec = vector;
            this.team = team;
            this.model = model;
            this.destroyed = false;

            if (start === undefined)
                start = Math.floor(random() * Plane.airports[team].length);
            if (typeof start == 'number') {
                // starting from airport, fix runway direction
                this.pos = Plane.airports[team][start].pos;
                this.vec.dir = Plane.airports[team][start].dir
            } else if (start instanceof Point)
                this.pos = start;

            for (const property in Plane.models[model])
                this[property] = Plane.models[model][property];

            // WSO
            this.missileCool = 0;
            this.missileGroupCount = this.missileGroup;
            this.flareCool = 0;
            this.flareGroupCount = this.flareGroup;

            // push trail history
            this.trail = Array.from({length: 5})
            this.trail.fill(this.pos.copy())

            Plane.list.push(this)
        }
        getNextPoint() {
            // get the next point with absolute coord
            let x = this.pos.x, y = this.pos.y,
                rel = this.vec.toPoint();
            return new Point(x + rel.x, y + rel.y)
        }
        tickMove(friendly, enemy) {
            this.pos = this.getNextPoint(); // go to next point

            // calculate next vector
            // find closest plane
            let minP = Infinity, minPlane;
            for (const plane of enemy) {
                let dis = Vector.fromPoints(this.pos, plane.pos);
                if (dis.len < minP) {
                    minP = dis.len;
                    minPlane = plane;
                }
            }

            // different between current heading and minPlane
            let dif = Vector.fromPoints(this.pos, minPlane.pos)
            let d = dif.dirDiff(this.vec); // direction difference

            // speed stuff
            let sd = dif.len - this.vec.len;
            if (abs(d) > 90 && this.vec.len > this.v1 + 1) // behind and still above V1, reduce speed
                sd = -this.acceleration;
            sd = (sd < 0)? max(sd, -this.acceleration) : min(sd, this.acceleration);
            this.vec.len += sd;
            this.vec.len = min(this.vec.len, this.maxSpeed)

            // direction
            if (this.vec.len < this.v1) return; // only turn and shot when above v1
            this.vec.dir += (d < 0)? max(d, -this.turnDeg) : min(d, this.turnDeg);

            // calculate weapon system (Heil Prez)
            this.missileCool--;
            if (this.missileCool < 0 && abs(d) < 30) {
                new Missile(this.pos.copy(), this.vec.copy(), minPlane.pos.copy(), this.team, this.missile);
                // refil firerate
                this.missileGroupCount--;
                if (this.missileGroupCount <= 0) {
                    // the group is out, refill
                    this.missileGroupCount = this.missileGroup;
                    this.missileCool = this.missileRate;
                }
            }

            // calculate flareSystem
            this.flareCool--;
            if (this.flareCool < 0) {
                let minM = Infinity, minMissile;
                for (
                    const missile of
                    Missile.list.filter(t =>
                        !t.isFlare
                        && t.team == Number(!Boolean(this.team))) // get the enemy team
                ) {
                    let dis = Vector.fromPoints(this.pos, missile.pos);
                    if (dis.len < minM) {
                        minM = dis.len;
                        minMissile = missile;
                    }
                }

                if (this.flareCool < 0 && minM < 1000) {
                    // separation vector
                    let vec = this.vec.copy();
                    vec.len += 50
                    vec.dir += randomItem([-1, 1]) * randomItem([45, 125]); // multiple flare angle
                    new Missile(this.pos.copy(), vec, minPlane.pos.copy(), this.team, this.flare);
                    // refil firerate
                    this.flareGroupCount--;
                    if (this.flareGroupCount <= 0) {
                        // the group is out, refill
                        this.flareGroupCount = this.flareGroup;
                        this.flareCool = this.flareRate;
                    }
                }
            }
        }
    }

    class Missile {
        static models = [
            {
                name: "Standard missile", // just a name
                maxSpeed: 340, // m/s
                acceleration: 300, // m/s^2
                v1: 0, // minimum speed, plane can start to turn after this
                turnDeg: 40, // turn degree per second
                fuel: 1000, // how many m before out of fuel
                exRad: 25, // explosion radius
            },
            {
                name: "Standard flare", // just a name
                isFlare: true, // it is a flare
                maxSpeed: 40, // m/s
                acceleration: 0, // m/s^2
                v1: 0, // minimum speed, plane can start to turn after this
                turnDeg: 0, // turn degree per second
                fuel: 250, // how many m before out of fuel
                exRad: 5, // explosion radius
            },
        ]
        static list = []
        constructor(pos, vec, tar, team, model) {
            this.pos = pos;
            this.vec = vec;
            this.tar = tar;
            this.team = team;
            this.model = model;
            this.destroyed = false;

            for (const property in Missile.models[model])
                this[property] = Missile.models[model][property];

            Missile.list.push(this)
        }
        getNextPoint() {
            // get the next point with absolute coord
            let x = this.pos.x, y = this.pos.y,
                rel = this.vec.toPoint();
            return new Point(x + rel.x, y + rel.y)
        }
        tickMove(targets) {
            this.pos = this.getNextPoint();
            this.fuel -= this.vec.len;
            if (this.fuel <= 0) return this.destroyed = true; // destroyed

            // find the closest provided entity compare to the old target
            let minT = Infinity, minTarget;
            for (const target of targets) {
                let dis = Vector.fromPoints(this.pos, target.pos);
                if (dis.len < minT) {
                    minT = dis.len;
                    minTarget = target;
                }
            }

            if (minT < this.exRad) {
                this.destroyed = true;
                minTarget.destroyed = true;
                return
            }

            // different between current heading and minPlane
            let dif = Vector.fromPoints(this.pos, minTarget.pos);

            // speed stuff
            let d = dif.len - this.vec.len;
            d = (d < 0)? max(d, -this.acceleration) : min(d, this.acceleration);
            this.vec.len += d;
            this.vec.len = min(this.vec.len, this.maxSpeed)

            // direction
            if (this.vec.len < this.v1) return; // only turn and shot when above v1
            d = dif.dirDiff(this.vec)
            this.vec.dir += (d < 0)? max(d, -this.turnDeg) : min(d, this.turnDeg);

            this.tar = minTarget.pos.copy();
        }
    }

    // all properties that are time-based will be multiplied by Delta
    const timeProp = [
        'maxSpeed',
        'acceleration',
        'v1',
        'turnDeg',
        'fireRate',
    ]
    for (const plane of Plane.models)
        for (const prop in plane)
            if (timeProp.includes(prop))
                plane[prop] *= Delta;
    for (const missile of Missile.models)
        for (const prop in missile)
            if (timeProp.includes(prop))
                missile[prop] *= Delta;
</script>
<script>
    // display
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // ctx.scale(0.1, 0.1)

    let currentStrokeType = ''; // current stroke to optimize

    const can = {
        setStroke: type => {
            // https://coolors.co/a63446-fbfef9-0c6291-fa824c-157f1f
            if (type === currentStrokeType) return; // no need to set again

            if (type == 't') {
                // trail
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#FA824C'
            } else if (type == 'r') {
                // rocket
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#fbfef9'
            } else if (type === 0) {
                // projected team 0
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#0C6291'
            } else if (type === 1) {
                // projected team 1
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#A63446'
            } else if (type == 'e') {
                // explosion
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#FA824C'
            } else if (type == 's') {
                // start
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#157F1F'
            }

        },
        line: (p1, p2, type) => {
            can.setStroke(type)
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        },
        circle: (cen, rad, type) => {
            // draw a circle with center as a point
            can.setStroke(type);
            ctx.beginPath();
            ctx.arc(cen.x, cen.y, rad, 0, 2 * PI);
            ctx.stroke();
        },
        tick: () => {
            ctx.rect(0, 0, 30000, 30000);
            ctx.fill();

            // prevent run order bias
            let i = floor(random() * Plane.list.length),
                j = floor(random() * Plane.list.length);
            [Plane.list[i], Plane.list[j]] = [Plane.list[j], Plane.list[i]];

            let team0 = Plane.list.filter(p => p.team === 0),
                team1 = Plane.list.filter(p => p.team === 1);

            // stat display
            document.getElementById('team0').innerText = team0.length;
            document.getElementById('team1').innerText = team1.length;
            document.getElementById('objects').innerText = Missile.list.length;

            for (let l1 = 0; l1 < Plane.list.length; l1++) {
                let plane = Plane.list[l1];

                if (plane.team == 0) plane.tickMove(team0, team1);
                else plane.tickMove(team1, team0);
                let p2 = plane.getNextPoint();

                plane.trail.pop();
                plane.trail.unshift(plane.pos.copy())
                for (let l1 = 0; l1 < plane.trail.length - 1; l1++)
                    can.line(plane.trail[l1], plane.trail[l1 + 1], 't');
                can.circle(plane.pos, plane.v1, plane.team)
                can.line(plane.pos, p2, plane.team)

                if (plane.destroyed) {
                    can.circle(plane.pos, 100, 'e')
                    Plane.list.splice(l1, 1);
                    l1--
                }
            };

            // add flares to the target list
            team0 = [...team0, ...Missile.list.filter(t => t.isFlare && t.team == 0)]
            team1 = [...team1, ...Missile.list.filter(t => t.isFlare && t.team == 1)]

            for (let l1 = 0; l1 < Missile.list.length; l1++) {
                let missile = Missile.list[l1];

                if (missile.team === 0) missile.tickMove(team1);
                else missile.tickMove(team0);

                can.line(missile.pos, missile.getNextPoint(), 'r')

                if (missile.destroyed) {
                    can.circle(missile.pos, missile.exRad, 'e')
                    Missile.list.splice(l1, 1);
                    l1--
                }
            }
        }
    }

    new Plane(new Vector(1, 0), 0, 0, new Point(1000, 2500))
    new Plane(new Vector(1, 180), 1, 0, new Point(4000, 2500))

    // shuffle
    Plane.list = Plane.list
        .map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ value }) => value);

    let sim = setInterval(() => {
        if (
            Plane.list.filter(r => r.team === 0).length <= 0
            || Plane.list.filter(r => r.team === 1).length <= 0
        ) return clearInterval(sim);
        can.tick();
    }, 1000 * Delta);
    can.tick()
</script>