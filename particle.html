<head>
    <style>
        body {
            padding: 0;
            margin: 0;
            background-color: black;
            color: white;
        }

        circle {
            stroke: none;
            fill: white;
            opacity: 0.5;
        }

        .splitTick {
            stroke: red;
            stroke-width: 10;
            opacity: 1;
        }
    </style>
</head>
<body>
    <svg id="svg" width="900" height="500"></svg>
    <div>
        <p>Total movement: <span id="totalMovement"></span></p>
        <button onclick="Bubble.tick()">Tick</button>
        <button onclick="splitTick()">Split tick <span id="splitTick">0</span></button>
        <button onclick="clearInterval(interval)">Clear interval</button>
    </div>
    <div>
        <input id="newRad" type="range" min="10" max="100">
    </div>
    <!--
        Each bubble as a "prefer" distance between other atom.
        If another bubble is inside the radius, it will push the other bubble out to the radius,
        (but the other bubble retain momentum, maybe?).
        This breaks the Law of Conservation, ruins the perfect elastic model, but I just want to see the world burn.
    -->
</body>
<script>
const svg = document.getElementById('svg'),
    namespace = 'http://www.w3.org/2000/svg',
    abs = Math.abs,
    random = Math.random,
    sin = Math.sin,
    cos = Math.cos,
    atan2 = Math.atan2,
    sqrt = Math.sqrt;

class Vector {
    constructor(length, heading) {
        if (typeof length != "number" || typeof heading != "number")
            throw TypeError('Input for Vector constructor must be number')
        this.len = length; this.hdg = heading;
    }
    // get the head of the vector from the tail location
    getPoint(tail) {
        return {
            x: tail.x + cos(this.hdg) * this.len,
            y: tail.y + sin(this.hdg) * this.len
        }
    }
    static fromPoints(p1, p2) {
        let x = p2.x - p1.x,
            y = p2.y - p1.y;
        return new Vector(sqrt(y*y + x*x), atan2(y, x))
    }
}

class Bubble {
    static list = [];
    static tick() {
        let totalMovement = 0;
        for (const bubble of Bubble.list)
            totalMovement += bubble.tick();

        document.getElementById('totalMovement').innerText = ~~totalMovement;

        return totalMovement;
    }

    constructor(x, y, radius) {
        this.pos = {x: x, y: y}; this.rad = radius;

        // display
        let circle = document.createElementNS(namespace, 'circle');
        this.elm = circle;
        circle.setAttribute('r', this.rad);
        this.updateDisplay();
        svg.append(circle);

        Bubble.list.push(this);
        return this;
    }
    updateDisplay() {
        // update display position
        this.elm.setAttribute('cx', this.pos.x);
        this.elm.setAttribute('cy', this.pos.y);
    }
    tick() {
        let totalMovement = 0;
        for (const bubble of Bubble.list) {
            if (bubble == this) continue; // skip itself
            let vec = Vector.fromPoints(this.pos, bubble.pos);
            if (vec.len > this.rad) continue; // out-of-range
            vec.len = abs(this.rad - vec.len); // move out of the radius
            totalMovement += vec.len; // add to movement calculation
            bubble.pos = vec.getPoint(bubble.pos);
            bubble.updateDisplay();
        }
        return totalMovement;
    }
}

// tick bubble individualy
let cur = 0;
function splitTick() {
    Bubble.list[cur].elm.classList.remove('splitTick')
    Bubble.list[cur].tick();
    cur++;
    if (cur == Bubble.list.length) cur = 0;
    Bubble.list[cur].elm.classList.add('splitTick')
    document.getElementById('splitTick').innerText = cur;
}

// Add bubble
svg.addEventListener('click', ev => {
    new Bubble(
        ev.clientX, ev.clientY,
        ~~document.getElementById('newRad').value
    )
})

let interval = setInterval(Bubble.tick, 250);
</script>